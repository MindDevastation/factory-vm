{% extends "base.html" %}
{% block body %}
<h1>Factory VM</h1>
<p class="muted">Последние 200 jobs</p>
<p>
  <form method="post" action="/ui/jobs/render_all" style="display:inline-block;margin-right:12px;">
    <button type="submit">Render All</button>
  </form>
  <a href="/ui/jobs/create">Create Job</a>
  <span class="muted" style="margin:0 8px;">|</span>
  <a href="/ui/db-viewer">Database</a>
</p>

<h2>Channels</h2>
<p>
  <button type="button" id="channel-add-btn">Add Channel (YouTube OAuth)</button>
  <button type="button" id="channels-refresh-btn">Refresh channels</button>
  <span class="muted" id="channel-note"></span>
</p>
<table id="channels-table">
  <thead>
    <tr>
      <th>Display name</th>
      <th>Slug</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="3" class="muted">Loading channels...</td>
    </tr>
  </tbody>
</table>

<h2>OAuth Tokens</h2>
<p>
  <button type="button" id="oauth-refresh-btn">Refresh status</button>
  <span class="muted" id="oauth-refresh-note"></span>
</p>
<table id="oauth-status-table">
  <thead>
    <tr>
      <th>Channel</th>
      <th>Drive Token</th>
      <th>YouTube Token</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="4" class="muted">Loading token status...</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Канал</th>
      <th>Релиз</th>
      <th>State</th>
      <th>Stage</th>
      <th>Progress</th>
      <th>Updated</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    {% for j in jobs %}
    <tr>
      <td><a href="/jobs/{{ j.id }}">{{ j.id }}</a></td>
      <td>{{ j.channel_name }}<div class="muted">{{ j.channel_slug }}</div></td>
      <td><a href="/jobs/{{ j.id }}">{{ j.channel_name }} - {{ j.release_title }}</a>
      {% if j.error_reason %}<div style="color:#b91c1c">{{ j.error_reason }}</div>{% endif %}</td>
      <td><span class="pill">{{ j.state }}</span></td>
      <td>{{ j.stage }}</td>
      <td>
        <div class="bar"><div style="width: {{ j.progress_pct }}%"></div></div>
        <div class="muted">{{ "%.1f"|format(j.progress_pct) }}% {{ j.progress_text or "" }}</div>
      </td>
      <td class="muted">{{ j.updated_at }}</td>
      <td>
        {% if j.state == 'DRAFT' and j.job_type == 'UI' %}
        <a href="/ui/jobs/{{ j.id }}/edit">Edit</a>
        {% endif %}
      </td>
    </tr>
    {% endfor %}
  </tbody>
</table>

<script>
(function () {
  const addBtn = document.getElementById('channel-add-btn');
  const channelsRefreshBtn = document.getElementById('channels-refresh-btn');
  const channelsTableBody = document.querySelector('#channels-table tbody');
  const channelNote = document.getElementById('channel-note');
  const refreshBtn = document.getElementById('oauth-refresh-btn');
  const refreshNote = document.getElementById('oauth-refresh-note');
  const oauthTableBody = document.querySelector('#oauth-status-table tbody');
  const trackJobStatusBySlug = {};
  const trackJobPollTimers = {};
  let pollCount = 0;
  function fmtStatus(isPresent, mtime) {
    if (!isPresent) {
      return 'Missing';
    }
    if (!mtime) {
      return 'Present';
    }
    const dt = new Date(Number(mtime) * 1000);
    if (Number.isNaN(dt.getTime())) {
      return 'Present';
    }
    return 'Present (' + dt.toLocaleString() + ')';
  }

  function extractApiErrorMessage(bodyText) {
    if (!bodyText) {
      return '';
    }
    try {
      const parsed = JSON.parse(bodyText);
      if (parsed && typeof parsed.detail === 'string') {
        return parsed.detail;
      }
    } catch (_) {
      // no-op: keep raw body text fallback
    }
    return bodyText;
  }

  function oauthStartError(status, detail, kind, slug) {
    const prefix = kind === 'gdrive' ? 'Drive OAuth' : 'YouTube OAuth';
    if (status === 404) {
      return 'Channel "' + slug + '" was not found. Refresh channels and try again.';
    }
    if (status === 500 && detail && detail.includes('is not configured')) {
      return prefix + ' is not configured on the server: ' + detail;
    }
    if (detail) {
      return prefix + ' failed: ' + detail;
    }
    return prefix + ' failed with status ' + status + '.';
  }

  async function startOauth(kind, slug) {
    const res = await fetch('/v1/oauth/' + kind + '/' + encodeURIComponent(slug) + '/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    });
    if (!res.ok) {
      const body = await res.text();
      const detail = extractApiErrorMessage(body);
      throw new Error(oauthStartError(res.status, detail, kind, slug));
    }
    const data = await res.json();
    if (!data.auth_url) {
      throw new Error('Missing auth_url in response');
    }
    window.open(data.auth_url, '_blank', 'noopener');
  }

  async function startChannelAddOauth() {
    const res = await fetch('/v1/oauth/youtube/add_channel/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    });
    if (!res.ok) {
      const body = await res.text();
      throw new Error('Failed to start Add Channel OAuth: ' + body);
    }
    const data = await res.json();
    if (!data.auth_url) {
      throw new Error('Missing auth_url in response');
    }
    window.open(data.auth_url, '_blank', 'noopener');
  }

  function esc(value) {
    return String(value)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('\"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function renderRows(channels) {
    if (!channels.length) {
      oauthTableBody.innerHTML = '<tr><td colspan="4" class="muted">No channels found.</td></tr>';
      return;
    }

    oauthTableBody.innerHTML = channels.map((ch) => {
      return '<tr>' +
        '<td>' + esc(ch.display_name) + '<div class="muted">' + esc(ch.slug) + '</div></td>' +
        '<td>' + fmtStatus(ch.drive_token_present, ch.drive_token_mtime) + '</td>' +
        '<td>' + fmtStatus(ch.yt_token_present, ch.yt_token_mtime) + '</td>' +
        '<td>' +
          '<button type="button" data-kind="gdrive" data-slug="' + esc(ch.slug) + '">' +
            (ch.drive_token_present ? 'Regenerate Drive Token' : 'Generate Drive Token') +
          '</button> ' +
          '<button type="button" data-kind="youtube" data-slug="' + esc(ch.slug) + '">Generate YouTube Token</button>' +
        '</td>' +
      '</tr>';
    }).join('');

    oauthTableBody.querySelectorAll('button[data-kind]').forEach((btn) => {
      btn.addEventListener('click', async () => {
        try {
          refreshNote.textContent = 'Starting OAuth flow...';
          await startOauth(btn.getAttribute('data-kind'), btn.getAttribute('data-slug'));
          refreshNote.textContent = 'OAuth window opened. Complete consent, then wait for auto-refresh or click Refresh status.';
          pollCount = 0;
          pollStatus();
        } catch (err) {
          refreshNote.textContent = err.message;
        }
      });
    });
  }

  async function fetchStatus() {
    const res = await fetch('/v1/oauth/status');
    if (!res.ok) {
      const body = await res.text();
      throw new Error('Failed to load OAuth status: ' + body);
    }
    const data = await res.json();
    return data.channels || [];
  }

  async function refreshStatus() {
    try {
      const channels = await fetchStatus();
      renderRows(channels);
      refreshNote.textContent = 'Updated at ' + new Date().toLocaleTimeString();
    } catch (err) {
      refreshNote.textContent = err.message;
    }
  }

  async function fetchChannels() {
    const res = await fetch('/v1/channels');
    if (!res.ok) {
      if (res.status === 401) {
        throw new Error('Not authorized');
      }
      throw new Error('Failed to load channels');
    }
    return await res.json();
  }

  async function fetchTrackCatalogChannels() {
    const res = await fetch('/v1/track_catalog/channels');
    if (!res.ok) {
      if (res.status === 401) {
        throw new Error('Not authorized');
      }
      throw new Error('Failed to load track catalog channels');
    }
    const data = await res.json();
    return (data && data.channels) || [];
  }

  async function triggerEnableTrackCatalog(slug) {
    const res = await fetch('/v1/track_catalog/' + encodeURIComponent(slug) + '/enable', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    });
    if (!res.ok) {
      const body = await res.text();
      throw new Error('Failed to enable Track Catalog: ' + extractApiErrorMessage(body));
    }
  }

  function scheduleTrackJobPoll(slug, jobId) {
    if (trackJobPollTimers[slug]) {
      clearTimeout(trackJobPollTimers[slug]);
    }
    trackJobPollTimers[slug] = setTimeout(async () => {
      try {
        const res = await fetch('/v1/track_jobs/' + encodeURIComponent(jobId));
        if (!res.ok) {
          throw new Error('Status check failed (' + res.status + ')');
        }
        const data = await res.json();
        const status = data && data.job && data.job.status ? String(data.job.status) : 'UNKNOWN';
        trackJobStatusBySlug[slug] = 'Track job ' + jobId + ': ' + status;
        renderTrackJobStatus(slug);
        if (status === 'QUEUED' || status === 'RUNNING') {
          scheduleTrackJobPoll(slug, jobId);
          return;
        }
      } catch (err) {
        trackJobStatusBySlug[slug] = 'Track job ' + jobId + ': ' + err.message;
        renderTrackJobStatus(slug);
      }
      delete trackJobPollTimers[slug];
    }, 2000);
  }

  function renderTrackJobStatus(slug) {
    const el = channelsTableBody.querySelector('span[data-track-status="' + slug + '"]');
    if (el) {
      el.textContent = trackJobStatusBySlug[slug] || '';
    }
  }

  async function triggerTrackJob(action, slug) {
    const endpoint = action === 'discover' ? '/v1/track_jobs/discover' : '/v1/track_jobs/analyze';
    const payload = action === 'discover'
      ? { channel_slug: slug }
      : { channel_slug: slug, scope: 'pending', max_tracks: 0, force: false };
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    if (!res.ok) {
      const body = await res.text();
      const detail = extractApiErrorMessage(body);
      if (detail === 'CHANNEL_NOT_IN_CANON') {
        throw new Error('Channel is not enabled for Track Catalog. Click Enable Track Catalog.');
      }
      throw new Error('Failed to launch track job: ' + detail);
    }
    const data = await res.json();
    const jobId = data && data.job_id ? String(data.job_id) : '';
    const status = data && data.status ? String(data.status) : 'QUEUED';
    if (!jobId) {
      throw new Error('Missing job_id in response');
    }
    trackJobStatusBySlug[slug] = 'Track job ' + jobId + ': ' + status;
    renderTrackJobStatus(slug);
    scheduleTrackJobPoll(slug, jobId);
  }

  function renderChannels(channels, enabledSlugs) {
    if (!channels.length) {
      channelsTableBody.innerHTML = '<tr><td colspan="3" class="muted">No channels found.</td></tr>';
      return;
    }
    channelsTableBody.innerHTML = channels.map((ch) => {
      const enabled = enabledSlugs.has(ch.slug);
      const trackControls = enabled
        ? '<button type="button" data-action="discover-tracks" data-slug="' + esc(ch.slug) + '">Discover Tracks</button> ' +
          '<button type="button" data-action="analyze-tracks" data-slug="' + esc(ch.slug) + '">Analyze Tracks</button>'
        : '<button type="button" data-action="enable-track-catalog" data-slug="' + esc(ch.slug) + '">Enable Track Catalog</button>' +
          '<div class="muted">Enable Track Catalog to use Discover/Analyze.</div>';
      return '<tr>' +
        '<td>' + esc(ch.display_name) + '</td>' +
        '<td><code>' + esc(ch.slug) + '</code></td>' +
        '<td>' +
          '<button type="button" data-action="rename" data-slug="' + esc(ch.slug) + '" data-display-name="' + esc(ch.display_name) + '">Rename</button> ' +
          '<button type="button" data-action="delete" data-slug="' + esc(ch.slug) + '">Delete</button> ' +
          trackControls +
          '<div class="muted"><span data-track-status="' + esc(ch.slug) + '">' + esc(trackJobStatusBySlug[ch.slug] || '') + '</span></div>' +
        '</td>' +
      '</tr>';
    }).join('');

    channelsTableBody.querySelectorAll('button[data-action="enable-track-catalog"]').forEach((btn) => {
      btn.addEventListener('click', async () => {
        const slug = btn.getAttribute('data-slug');
        const originalLabel = btn.textContent;
        btn.disabled = true;
        btn.textContent = 'Enabling...';
        try {
          await triggerEnableTrackCatalog(slug);
          channelNote.textContent = 'Track Catalog enabled for "' + slug + '".';
          await refreshAll();
        } catch (err) {
          channelNote.textContent = err.message;
        } finally {
          btn.disabled = false;
          btn.textContent = originalLabel;
        }
      });
    });

    channelsTableBody.querySelectorAll('button[data-action="rename"]').forEach((btn) => {
      btn.addEventListener('click', async () => {
        const slug = btn.getAttribute('data-slug');
        const currentName = btn.getAttribute('data-display-name') || '';
        const nextName = window.prompt('Rename channel "' + slug + '"', currentName);
        if (nextName === null) {
          return;
        }
        const trimmedName = nextName.trim();
        if (!trimmedName) {
          channelNote.textContent = 'Display name is required';
          return;
        }
        channelNote.textContent = '';
        try {
          const res = await fetch('/v1/channels/' + encodeURIComponent(slug), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ display_name: trimmedName }),
          });
          if (!res.ok) {
            if (res.status === 401) {
              throw new Error('Not authorized');
            }
            if (res.status === 422) {
              throw new Error('Invalid display name');
            }
            const body = await res.text();
            throw new Error('Failed to rename channel: ' + body);
          }
          channelNote.textContent = 'Channel renamed';
          await refreshAll();
        } catch (err) {
          channelNote.textContent = err.message;
        }
      });
    });

    channelsTableBody.querySelectorAll('button[data-action="delete"]').forEach((btn) => {
      btn.addEventListener('click', async () => {
        const slug = btn.getAttribute('data-slug');
        if (!window.confirm('Delete channel "' + slug + '"?')) {
          return;
        }
        channelNote.textContent = '';
        try {
          const res = await fetch('/v1/channels/' + encodeURIComponent(slug), { method: 'DELETE' });
          if (!res.ok) {
            if (res.status === 401) {
              throw new Error('Not authorized');
            }
            if (res.status === 409) {
              throw new Error('Cannot delete channel: channel has jobs');
            }
            const body = await res.text();
            throw new Error('Failed to delete channel: ' + body);
          }
          channelNote.textContent = 'Channel deleted';
          await refreshAll();
        } catch (err) {
          channelNote.textContent = err.message;
        }
      });
    });

    channelsTableBody.querySelectorAll('button[data-action="discover-tracks"], button[data-action="analyze-tracks"]').forEach((btn) => {
      btn.addEventListener('click', async () => {
        const slug = btn.getAttribute('data-slug');
        const action = btn.getAttribute('data-action') === 'discover-tracks' ? 'discover' : 'analyze';
        const originalLabel = btn.textContent;
        btn.disabled = true;
        btn.textContent = action === 'discover' ? 'Starting discover...' : 'Starting analyze...';
        try {
          await triggerTrackJob(action, slug);
          channelNote.textContent = 'Track job queued for "' + slug + '".';
        } catch (err) {
          const message = err && err.message ? err.message : 'Failed to launch track job';
          trackJobStatusBySlug[slug] = message;
          renderTrackJobStatus(slug);
          channelNote.textContent = message;
          window.alert(message);
        } finally {
          btn.disabled = false;
          btn.textContent = originalLabel;
        }
      });
    });
  }

  async function refreshAll() {
    try {
      const channels = await fetchChannels();
      const catalogChannels = await fetchTrackCatalogChannels();
      const enabledSlugs = new Set(catalogChannels.map((ch) => ch.slug));
      renderChannels(channels, enabledSlugs);
    } catch (err) {
      channelsTableBody.innerHTML = '<tr><td colspan="3" class="muted">' + esc(err.message) + '</td></tr>';
    }
    await refreshStatus();
  }

  function pollStatus() {
    if (pollCount >= 20) {
      return;
    }
    pollCount += 1;
    setTimeout(async () => {
      await refreshStatus();
      pollStatus();
    }, 3000);
  }

  addBtn.addEventListener('click', async () => {
    try {
      channelNote.textContent = 'Starting YouTube OAuth flow...';
      await startChannelAddOauth();
      channelNote.textContent = 'OAuth window opened. Complete consent, then return and refresh channels.';
      pollCount = 0;
      pollStatus();
    } catch (err) {
      channelNote.textContent = err.message;
    }
  });
  channelsRefreshBtn.addEventListener('click', refreshAll);
  window.addEventListener('focus', () => {
    refreshAll();
  });
  refreshBtn.addEventListener('click', refreshAll);
  refreshAll();
})();
</script>
{% endblock %}
